#!/usr/bin/env ruby

require 'cpu'
require 'spruz/go'
include Spruz::GO
require 'bullshit'

class ParseCommands
  def self.parse(argv)
    new(argv).parse
  end

  def initialize(argv)
    @argv = argv
  end

  def set_t_j_max(temp)
    t_j_max = temp and CPU.t_j_max = t_j_max.to_i
  end

  def create_history_path(filename)
    filename ||= '~/.coretemp-history'
    File.expand_path(filename)
  end

  def measure_temps(opts)
    set_t_j_max opts['t']
    CPU.each_core.map(&:temperature)
  end

  def simple
    opts = go 't', @argv
    puts measure_temps(opts) * ' '
  end

  def collect
    opts = go 'tf', @argv
    filename = create_history_path opts['f']
    temperatures = measure_temps(opts)
    line = ([ Time.now.to_f ] + temperatures) * ' '
    if filename
      open(filename, 'a') do |o|
        o.puts line
      end
    end
  end

  def clear
    opts = go 'f', @argv
    filename = create_history_path opts['f']
    if filename and File.exist?(filename)
      File.unlink(filename)
    end
  end

  def stats
    opts = go 'f', @argv
    filename = create_history_path opts['f']
    if filename and File.exist?(filename)
      history = open(filename, 'r') { |o|
        o.map do |line|
          time, *temps = line.split(/\s+/)
          [ Time.at(Float(time)) ] + temps.map { |t| Integer(t) }
        end
      }
      measurements_last = history.last[1..-1]
      times, *measurements = history.transpose
      analyses = measurements.map { |m| Bullshit::Analysis.new(m) }
      puts " min: %s" % (analyses.map { |a| a.min  } * ' ')
      puts "last: %s" % (measurements_last * ' ')
      puts " max: %s" % (analyses.map { |a| a.max  } * ' ')
      puts "mean: %s" % (analyses.map { |a| a.mean.round } * ' ')
    end
  end

  def parse
    case command = @argv.shift
    when 'collect'       then collect
    when 'clear'         then clear
    when 'stats'         then stats
    when 'collect_stats' then collect; stats
    else                      simple
    end
  end
end

if $0 == __FILE__
  ParseCommands.parse(ARGV)
end
